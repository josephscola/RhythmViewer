
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Using type annotations &#8212; My sample book</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../../../../_static/pygments.css" />
    <link rel="stylesheet" href="../../../../../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../../../../../" id="documentation_options" src="../../../../../../_static/documentation_options.js"></script>
    <script src="../../../../../../_static/jquery.js"></script>
    <script src="../../../../../../_static/underscore.js"></script>
    <script src="../../../../../../_static/doctools.js"></script>
    <script src="../../../../../../_static/clipboard.min.js"></script>
    <script src="../../../../../../_static/copybutton.js"></script>
    <script src="../../../../../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../../../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../../../../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../../../../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../../../../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../../../../../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">My sample book</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../../../../../intro.html">
                    Welcome to your Jupyter Book
                </a>
            </li>
        </ul>
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../../markdown.html">
   Markdown Files
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../../notebooks.html">
   Content with notebooks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../../markdown-notebooks.html">
   Notebooks with MyST Markdown
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/executablebooks/jupyter-book"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2Fenv/lib/python3.9/site-packages/mypyc/doc/using_type_annotations.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../../../../../../_sources/env/lib/python3.9/site-packages/mypyc/doc/using_type_annotations.rst"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.rst</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#primitive-types">
   Primitive types
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#primitive-containers">
   Primitive containers
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#native-classes">
   Native classes
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#tuple-types">
   Tuple types
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#union-types">
   Union types
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#trait-types">
   Trait types
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#erased-types">
   Erased types
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#strict-runtime-type-checking">
   Strict runtime type checking
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#value-and-heap-types">
   Value and heap types
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#native-integer-types">
   Native integer types
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Using type annotations</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#primitive-types">
   Primitive types
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#primitive-containers">
   Primitive containers
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#native-classes">
   Native classes
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#tuple-types">
   Tuple types
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#union-types">
   Union types
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#trait-types">
   Trait types
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#erased-types">
   Erased types
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#strict-runtime-type-checking">
   Strict runtime type checking
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#value-and-heap-types">
   Value and heap types
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#native-integer-types">
   Native integer types
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section id="using-type-annotations">
<span id="id1"></span><h1>Using type annotations<a class="headerlink" href="#using-type-annotations" title="Permalink to this headline">#</a></h1>
<p>You will get the most out of mypyc if you compile code with precise
type annotations. Not all type annotations will help performance
equally, however. Using types such as <a class="reference internal" href="#primitive-types"><span class="std std-ref">primitive types</span></a>, <a class="reference internal" href="#native-class-intro"><span class="std std-ref">native classes</span></a>,
<a class="reference internal" href="#union-types"><span class="std std-ref">union types</span></a>, <a class="reference internal" href="#trait-types"><span class="std std-ref">trait types</span></a>,
and <a class="reference internal" href="#tuple-types"><span class="std std-ref">tuple types</span></a> as much as possible is a key to
major performance gains over CPython.</p>
<p>In contrast, some other types, including <code class="docutils literal notranslate"><span class="pre">Any</span></code>, are treated as
<a class="reference internal" href="#erased-types"><span class="std std-ref">erased types</span></a>.  Operations on erased types use
generic operations that work with arbitrary objects, similar to how
the CPython interpreter works. If you only use erased types, the only
notable benefits over CPython will be the removal of interpreter
overhead (from compilation) and a bit of <a class="reference internal" href="differences_from_python.html#early-binding"><span class="std std-ref">early binding</span></a>, which will usually only give minor performance
gains.</p>
<section id="primitive-types">
<span id="id2"></span><h2>Primitive types<a class="headerlink" href="#primitive-types" title="Permalink to this headline">#</a></h2>
<p>The following built-in types are treated as <em>primitive types</em> by
mypyc, and many operations on these types have efficient
implementations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">int</span></code> (<a class="reference internal" href="int_operations.html#int-ops"><span class="std std-ref">native operations</span></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i64</span></code> (<a class="reference internal" href="#native-ints"><span class="std std-ref">documentation</span></a>, <a class="reference internal" href="int_operations.html#int-ops"><span class="std std-ref">native operations</span></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i32</span></code> (<a class="reference internal" href="#native-ints"><span class="std std-ref">documentation</span></a>, <a class="reference internal" href="int_operations.html#int-ops"><span class="std std-ref">native operations</span></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float</span></code> (<a class="reference internal" href="float_operations.html#float-ops"><span class="std std-ref">native operations</span></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span></code> (<a class="reference internal" href="bool_operations.html#bool-ops"><span class="std std-ref">native operations</span></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code> (<a class="reference internal" href="str_operations.html#str-ops"><span class="std std-ref">native operations</span></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">List[T]</span></code> (<a class="reference internal" href="list_operations.html#list-ops"><span class="std std-ref">native operations</span></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Dict[K,</span> <span class="pre">V]</span></code> (<a class="reference internal" href="dict_operations.html#dict-ops"><span class="std std-ref">native operations</span></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Set[T]</span></code> (<a class="reference internal" href="set_operations.html#set-ops"><span class="std std-ref">native operations</span></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Tuple[T,</span> <span class="pre">...]</span></code> (variable-length tuple; <a class="reference internal" href="tuple_operations.html#tuple-ops"><span class="std std-ref">native operations</span></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
</ul>
<p>The link after each type lists all supported native, optimized
operations for the type. You can use all operations supported by
Python, but <em>native operations</em> will have custom, optimized
implementations.</p>
</section>
<section id="primitive-containers">
<h2>Primitive containers<a class="headerlink" href="#primitive-containers" title="Permalink to this headline">#</a></h2>
<p>Primitive container objects such as <code class="docutils literal notranslate"><span class="pre">list</span></code> and <code class="docutils literal notranslate"><span class="pre">dict</span></code> don’t
maintain knowledge of the item types at runtime – the item type is
<em>erased</em>.</p>
<p>This means that item types are checked when items are accessed, not
when a container is passed as an argument or assigned to another
variable. For example, here we have a runtime type error on the final
line of <code class="docutils literal notranslate"><span class="pre">example</span></code> (the <code class="docutils literal notranslate"><span class="pre">Any</span></code> type means an arbitrary, unchecked
value):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Any</span>

<span class="k">def</span> <span class="nf">example</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>  <span class="c1"># No error -- items are not checked</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Error here -- got str, but expected int</span>

<span class="n">example</span><span class="p">([</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="native-classes">
<span id="native-class-intro"></span><h2>Native classes<a class="headerlink" href="#native-classes" title="Permalink to this headline">#</a></h2>
<p>Classes that get compiled to C extensions are called native
classes. Most common operations on instances of these classes are
optimized, including construction, attribute access and method calls.</p>
<p>Native class definitions look exactly like normal Python class
definitions.  A class is usually native if it’s in a compiled module
(though there are some exceptions).</p>
<p>Consider this example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">Point</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Point</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>All operations in the above example use native operations, if the file
is compiled.</p>
<p>Native classes have some notable different from Python classes:</p>
<ul class="simple">
<li><p>Only attributes and methods defined in the class body or methods are
supported.  If you try to assign to an undefined attribute outside
the class definition, <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code> will be raised. This enables
an efficient memory layout and fast method calls for native classes.</p></li>
<li><p>Native classes usually don’t define the <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> attribute (they
don’t have an attribute dictionary). This follows from only having
a specific set of attributes.</p></li>
<li><p>Native classes can’t have an arbitrary metaclass or use most class
decorators.</p></li>
</ul>
<p>Native classes only support single inheritance. A limited form of
multiple inheritance is supported through <em>trait types</em>. You generally
must inherit from another native class (or <code class="docutils literal notranslate"><span class="pre">object</span></code>). By default,
you can’t inherit a Python class from a native class (but there’s
an <a class="reference internal" href="native_classes.html#inheritance"><span class="std std-ref">override</span></a> to allow that).</p>
<p>See <a class="reference internal" href="native_classes.html#native-classes"><span class="std std-ref">Native classes</span></a> for more details.</p>
</section>
<section id="tuple-types">
<span id="id3"></span><h2>Tuple types<a class="headerlink" href="#tuple-types" title="Permalink to this headline">#</a></h2>
<p>Fixed-length
<a class="reference external" href="https://mypy.readthedocs.io/en/stable/kinds_of_types.html#tuple-types">tuple types</a>
such as <code class="docutils literal notranslate"><span class="pre">Tuple[int,</span> <span class="pre">str]</span></code> are represented
as <a class="reference internal" href="#value-and-heap-types"><span class="std std-ref">value types</span></a> when stored in variables,
passed as arguments, or returned from functions. Value types are
allocated in the low-level machine stack or in CPU registers, as
opposed to <em>heap types</em>, which are allocated dynamically from the
heap.</p>
<p>Like all value types, tuples will be <em>boxed</em>, i.e. converted to
corresponding heap types, when stored in Python containers, or passed
to non-native code. A boxed tuple value will be a regular Python tuple
object.</p>
</section>
<section id="union-types">
<span id="id5"></span><h2>Union types<a class="headerlink" href="#union-types" title="Permalink to this headline">#</a></h2>
<p><a class="reference external" href="https://mypy.readthedocs.io/en/stable/kinds_of_types.html#union-types">Union types</a>
and
<a class="reference external" href="https://mypy.readthedocs.io/en/stable/kinds_of_types.html#optional-types-and-the-none-type">optional types</a>
that contain primitive types, native class types and
trait types are also efficient. If a union type has
<a class="reference internal" href="#erased-types"><span class="std std-ref">erased</span></a> items, accessing items with
non-erased types is often still quite efficient.</p>
<p>A value with a union types is always <a class="reference internal" href="#value-and-heap-types"><span class="std std-ref">boxed</span></a>,
even if it contains a value that also has an unboxed representation, such
as an integer or a boolean.</p>
<p>For example, using <code class="docutils literal notranslate"><span class="pre">Optional[int]</span></code> is quite efficient, but the value
will always be boxed. A plain <code class="docutils literal notranslate"><span class="pre">int</span></code> value will usually be faster, since
it has an unboxed representation.</p>
</section>
<section id="trait-types">
<span id="id7"></span><h2>Trait types<a class="headerlink" href="#trait-types" title="Permalink to this headline">#</a></h2>
<p>Trait types enable a form of multiple inheritance for native classes.
A native class can inherit any number of traits.  Trait types are
defined as classes using the <code class="docutils literal notranslate"><span class="pre">mypy_extensions.trait</span></code> decorator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mypy_extensions</span> <span class="kn">import</span> <span class="n">trait</span>

<span class="nd">@trait</span>
<span class="k">class</span> <span class="nc">MyTrait</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>Traits can define methods, properties and attributes. They often
define abstract methods. Traits can be generic.</p>
<p>If a class subclasses both a non-trait class and traits, the traits
must be placed at the end of the base class list:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">:</span> <span class="o">...</span>

<span class="k">class</span> <span class="nc">Derived</span><span class="p">(</span><span class="n">Base</span><span class="p">,</span> <span class="n">MyTrait</span><span class="p">,</span> <span class="n">FooTrait</span><span class="p">):</span>  <span class="c1"># OK</span>
    <span class="o">...</span>

<span class="k">class</span> <span class="nc">Derived2</span><span class="p">(</span><span class="n">MyTrait</span><span class="p">,</span> <span class="n">FooTrait</span><span class="p">,</span> <span class="n">Base</span><span class="p">):</span>
    <span class="c1"># Error: traits should come last</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Traits have some special properties:</p>
<ul class="simple">
<li><p>You shouldn’t create instances of traits (though mypyc does not
prevent it yet).</p></li>
<li><p>Traits can subclass other traits, but they can’t subclass non-trait
classes (other than <code class="docutils literal notranslate"><span class="pre">object</span></code>).</p></li>
<li><p>Accessing methods or attributes through a trait type is somewhat
less efficient than through a native class type, but this is much
faster than through Python class types or other
<a class="reference internal" href="#erased-types"><span class="std std-ref">erased types</span></a>.</p></li>
</ul>
<p>You need to install <code class="docutils literal notranslate"><span class="pre">mypy-extensions</span></code> to use <code class="docutils literal notranslate"><span class="pre">&#64;trait</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>pip install --upgrade mypy-extensions
</pre></div>
</div>
</section>
<section id="erased-types">
<span id="id8"></span><h2>Erased types<a class="headerlink" href="#erased-types" title="Permalink to this headline">#</a></h2>
<p>Mypyc supports many other kinds of types as well, beyond those
described above.  However, these types don’t have customized
operations, and they are implemented using <em>type erasure</em>.  Type
erasure means that all other types are equivalent to untyped values at
runtime, i.e. they are the equivalent of the type <code class="docutils literal notranslate"><span class="pre">Any</span></code>. Erased
types include these:</p>
<ul class="simple">
<li><p>Python classes (including ABCs)</p></li>
<li><p>Non-mypyc extension types and primitive types (including built-in
types that are not primitives)</p></li>
<li><p><a class="reference external" href="https://mypy.readthedocs.io/en/stable/kinds_of_types.html#callable-types-and-lambdas">Callable types</a></p></li>
<li><p><a class="reference external" href="https://mypy.readthedocs.io/en/stable/generics.html">Type variable types</a></p></li>
<li><p>Type <a class="reference external" href="https://mypy.readthedocs.io/en/stable/dynamic_typing.html">Any</a></p></li>
<li><p>Protocol types</p></li>
</ul>
<p>Using erased types can still improve performance, since they can
enable better types to be inferred for expressions that use these
types.  For example, a value with type <code class="docutils literal notranslate"><span class="pre">Callable[[],</span> <span class="pre">int]</span></code> will not
allow native calls. However, the return type is a primitive type, and
we can use fast operations on the return value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span>

<span class="k">def</span> <span class="nf">call_and_inc</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Slow call, since f has an erased type</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span>
    <span class="c1"># Fast increment; inferred type of n is int (primitive type)</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">n</span>
</pre></div>
</div>
<p>If the type of the argument <code class="docutils literal notranslate"><span class="pre">f</span></code> was <code class="docutils literal notranslate"><span class="pre">Any</span></code>, the type of <code class="docutils literal notranslate"><span class="pre">n</span></code> would
also be <code class="docutils literal notranslate"><span class="pre">Any</span></code>, resulting in a generic, slower increment operation
being used.</p>
</section>
<section id="strict-runtime-type-checking">
<h2>Strict runtime type checking<a class="headerlink" href="#strict-runtime-type-checking" title="Permalink to this headline">#</a></h2>
<p>Compiled code ensures that any variable or expression with a
non-erased type only has compatible values at runtime. This is in
contrast with using <em>optional static typing</em>, such as by using mypy,
when type annotations are not enforced at runtime. Mypyc ensures
type safety both statically and at runtime.</p>
<p><code class="docutils literal notranslate"><span class="pre">Any</span></code> types and erased types in general can compromise type safety,
and this is by design. Inserting strict runtime type checks for all
possible values would be too expensive and against the goal of
high performance.</p>
</section>
<section id="value-and-heap-types">
<span id="id9"></span><h2>Value and heap types<a class="headerlink" href="#value-and-heap-types" title="Permalink to this headline">#</a></h2>
<p>In CPython, memory for all objects is dynamically allocated on the
heap. All Python types are thus <em>heap types</em>. In compiled code, some
types are <em>value types</em> – no object is (necessarily) allocated on the
heap.  <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code>, <a class="reference internal" href="#native-ints"><span class="std std-ref">native integer types</span></a>
and fixed-length tuples are value types.</p>
<p><code class="docutils literal notranslate"><span class="pre">int</span></code> is a hybrid. For typical integer values, it is a value
type. Large enough integer values, those that require more than 63
bits (or 31 bits on 32-bit platforms) to represent, use a heap-based
representation (same as CPython).</p>
<p>Value types have a few differences from heap types:</p>
<ul class="simple">
<li><p>When an instance of a value type is used in a context that expects a
heap value, for example as a list item, it will transparently switch
to a heap-based representation (boxing) as needed.</p></li>
<li><p>Similarly, mypyc transparently changes from a heap-based
representation to a value representation (unboxing).</p></li>
<li><p>Object identity of integers, floating point values and tuples is not
preserved. You should use <code class="docutils literal notranslate"><span class="pre">==</span></code> instead of <code class="docutils literal notranslate"><span class="pre">is</span></code> if you are comparing
two integers, floats or fixed-length tuples.</p></li>
<li><p>When an instance of a subclass of a value type is converted to the
base type, it is implicitly converted to an instance of the target
type.  For example, a <code class="docutils literal notranslate"><span class="pre">bool</span></code> value assigned to a variable with an
<code class="docutils literal notranslate"><span class="pre">int</span></code> type will be converted to the corresponding integer.</p></li>
</ul>
<p>The latter conversion is the only implicit type conversion that
happens in mypyc programs.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">example</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># A small integer uses the value (unboxed) representation</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="c1"># A large integer uses the heap (boxed) representation</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">500</span>
    <span class="c1"># Lists always contain boxed integers</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">55</span><span class="p">]</span>
    <span class="c1"># When reading from a list, the object is automatically unboxed</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># True is converted to 1 on assignment</span>
    <span class="n">x</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>Since integers and floating point values have a different runtime
representations and neither can represent all the values of the other
type, type narrowing of floating point values through assignment is
disallowed in compiled code. For consistency, mypyc rejects assigning
an integer value to a float variable even in variable initialization.
An explicit conversion is required.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">narrowing</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Error: Incompatible value representations in assignment</span>
    <span class="c1"># (expression has type &quot;int&quot;, variable has type &quot;float&quot;)</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">y</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Ok</span>

    <span class="k">if</span> <span class="n">f</span><span class="p">():</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">n</span>  <span class="c1"># Error</span>
    <span class="k">if</span> <span class="n">f</span><span class="p">():</span>
        <span class="n">y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>  <span class="c1"># Ok</span>
</pre></div>
</div>
</section>
<section id="native-integer-types">
<span id="native-ints"></span><h2>Native integer types<a class="headerlink" href="#native-integer-types" title="Permalink to this headline">#</a></h2>
<p>You can use the native integer types <code class="docutils literal notranslate"><span class="pre">i64</span></code> (64-bit signed integer)
and <code class="docutils literal notranslate"><span class="pre">i32</span></code> (32-bit signed integer) if you know that integer values
will always fit within fixed bounds. These types are faster than the
arbitrary-precision <code class="docutils literal notranslate"><span class="pre">int</span></code> type, since they don’t require overflow
checks on operations. <code class="docutils literal notranslate"><span class="pre">i32</span></code> may also use less memory than <code class="docutils literal notranslate"><span class="pre">int</span></code>
values. The types are imported from the <code class="docutils literal notranslate"><span class="pre">mypy_extensions</span></code> module
(installed via <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">mypy_extensions</span></code>).</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mypy_extensions</span> <span class="kn">import</span> <span class="n">i64</span>

<span class="k">def</span> <span class="nf">sum_list</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">i64</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">i64</span><span class="p">:</span>
    <span class="n">s</span><span class="p">:</span> <span class="n">i64</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">s</span>

<span class="c1"># Implicit conversions from int to i64</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sum_list</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since there are no overflow checks when performing native integer
arithmetic, the above function could result in an overflow or other
undefined behavior if the sum might not fit within 64 bits.</p>
<p>The behavior when running as interpreted Python program will be
different if there are overflows. Declaring native integer types
have no effect unless code is compiled. Native integer types are
effectively equivalent to <code class="docutils literal notranslate"><span class="pre">int</span></code> when interpreted.</p>
</div>
<p>Native integer types have these additional properties:</p>
<ul class="simple">
<li><p>Values can be implicitly converted between <code class="docutils literal notranslate"><span class="pre">int</span></code> and a native
integer type (both ways).</p></li>
<li><p>Conversions between different native integer types must be explicit.
A conversion to a narrower native integer type truncates the value
without a runtime overflow check.</p></li>
<li><p>If a binary operation (such as <code class="docutils literal notranslate"><span class="pre">+</span></code>) or an augmented assignment
(such as <code class="docutils literal notranslate"><span class="pre">+=</span></code>) mixes native integer and <code class="docutils literal notranslate"><span class="pre">int</span></code> values, the
<code class="docutils literal notranslate"><span class="pre">int</span></code> operand is implicitly coerced to the native integer type
(native integer types are “sticky”).</p></li>
<li><p>You can’t mix different native integer types in binary
operations. Instead, convert between types explicitly.</p></li>
</ul>
<p>For more information about native integer types, refer to
<a class="reference internal" href="int_operations.html#int-ops"><span class="std std-ref">native integer operations</span></a>.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./env/lib/python3.9/site-packages/mypyc/doc"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By The Jupyter Book Community<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>